{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Discrete Portfolio Optimization","text":"<p>This is the documentation for the Discrete Portfolio Optimization package.</p>"},{"location":"#why-this-package","title":"Why this package","text":"<p>This package differs from other portfolio optimization packages, such as PyPortfolioOpt, in its fundamental approach to handling financial instruments. Unlike packages that assume continuous holdings of assets, this package explicitly accounts for the discrete nature of financial instruments (i.e., you can only buy or sell whole shares).</p> <p>This discrete constraint renders the optimization problem non-convex, making it unsuitable for traditional convex optimization techniques. To address this, the Discrete Portfolio Optimization package integrates a custom optimization algorithm based on the Simulated Annealing (SA) algorithm. SA is a probabilistic technique that can effectively explore the solution space of non-convex problems, allowing the package to find optimal or near-optimal portfolio allocations even with the real-world constraint of discrete asset quantities.</p> <p>In essence, this package provides a more realistic and practical approach to portfolio optimization by directly tackling the challenges posed by the discrete nature of asset holdings, a crucial aspect often overlooked in other tools.</p>"},{"location":"#how-to-use-dpo","title":"How to use DPO","text":""},{"location":"#main-idea-and-equation","title":"Main idea and equation","text":"<p>The core idea of this package is to optimize a portfolio of assets where the holdings must be integers (discrete shares). This is a non-convex optimization problem, which is solved here using the Simulated Annealing algorithm.</p> <p>The algorithm explores the space of possible portfolios by making random moves (swapping assets) and accepting or rejecting these moves based on a probability that depends on the change in the portfolio's \"score\" and a \"temperature\" parameter ($\\theta$).</p> <p>The objective function (Score) being maximized is defined as:</p> <p>$$ \\text{Score} = \\text{Return} - \\eta \\cdot \\text{Volatility} - \\gamma \\sum w_i^2 - \\delta \\frac{\\text{Cash}}{\\text{Total Value}} $$</p> <p>Where:</p> <ul> <li>Return: Expected daily return of the portfolio.</li> <li>Volatility: Expected daily volatility (risk) of the portfolio.</li> <li>$\\eta$ (eta): Risk aversion parameter. Larger $\\eta$ leads to lower volatility portfolios.</li> <li>$\\gamma$ (gamma): Diversification parameter. Larger $\\gamma$ penalizes concentrated portfolios (high sum of squared weights), encouraging diversification.</li> <li>$\\delta$ (delta): Cash penalty parameter. Larger $\\delta$ penalizes holding cash, encouraging full investment.</li> <li>$w_i$: Weight of asset $i$ in the portfolio.</li> </ul> <p>The algorithm runs for a sequence of decreasing temperatures (simulating the cooling process in annealing), allowing it to escape local optima initially and then settle into a global optimum.</p>"},{"location":"#how-to-use-the-frontend","title":"How to use the frontend","text":"<p>The package includes a web-based user interface built with marimo. To launch the frontend, run the following command in your terminal:</p> <pre><code>uv run marimo edit UI/DPO_UserInterface.py\n</code></pre> <p>This will open a browser window where you can:</p> <ol> <li>Enter stock symbols to download data from Yahoo Finance.</li> <li>Configure optimization parameters (total value, risk aversion $\\eta$, etc.).</li> <li>Run the optimization and visualize the results (efficient frontier, portfolio composition, etc.).</li> </ol>"},{"location":"#how-to-contribute","title":"How to contribute","text":""},{"location":"#prepare-the-local-environment","title":"Prepare the local environment","text":"<p>First, install <code>uv</code> using the command above. Then, create a new virtual environment using <code>uv</code>:</p> <pre><code>uv sync\n</code></pre> <p>(this step is not strictly necessary, it will be done automatically at the first <code>uv run</code> command)</p>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>To install pre-commit hooks, run the following command:</p> <pre><code>uv run pre-commit install\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>To run the tests, use the following command:</p> <pre><code>uv run pytest --cov=src\n</code></pre>"},{"location":"metropolis/","title":"Metropolis","text":""},{"location":"metropolis/#DiscretePortfolioOptimization.metropolis","title":"<code>DiscretePortfolioOptimization.metropolis</code>","text":""},{"location":"metropolis/#DiscretePortfolioOptimization.metropolis.PortfolioOptimizer","title":"<code>PortfolioOptimizer</code>","text":"<p>Class to optimize a portfolio using the Metropolis algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>initial_portfolio</code> <code>Portfolio</code> <p>Portfolio, the initial portfolio to optimize</p> required <code>returns_df</code> <code>DataFrame</code> <p>pd.DataFrame, the returns of the assets in the portfolio</p> required <code>eta0</code> <code>float</code> <p>float, the smallest eta to use (larger eta -&gt; lower volatility)</p> <code>10.0</code> <code>eta1</code> <code>float</code> <p>float, the largest eta to use (larger eta -&gt; lower volatility)</p> <code>1000.0</code> <code>n_etas</code> <code>int</code> <p>int, the number of etas to use, so the number of final optimized portfolios</p> <code>10</code> <code>gamma</code> <code>float</code> <p>float, the gamma parameter to use (larger gamma -&gt; more diversified portfolio)</p> <code>0.0</code> <code>delta</code> <code>float</code> <p>float, the delta parameter to use (larger delta -&gt; less cash in the portfolio)</p> <code>0.0</code> <code>n_therm_steps</code> <code>int</code> <p>int, the number of thermalization steps to use before starting the optimization</p> <code>1000</code> <code>theta0</code> <code>float</code> <p>float, the initial theta for the Simulated Annealing algorithm. It should be so that <code>theta0 * score_diff &lt;&lt; 1</code> where <code>score_diff</code> is the difference between the scores of two portfolios separated by a random move.</p> <code>1</code> <code>theta1</code> <code>float</code> <p>float, the final theta for the Simulated Annealing algorithm. It should be so that <code>theta1 * score_diff &gt;&gt; 1</code> where <code>score_diff</code> is the difference between the scores of two portfolios separated by a random move.</p> <code>1000.0</code> <code>n_thetas</code> <code>int</code> <p>int, the number of thetas to use in the Simulated Annealing algorithm. Larger values will make the algorithm more precise but slower.</p> <code>5000</code> <code>n_steps_per_theta</code> <code>int</code> <p>int, the number of steps per theta to use in the Simulated Annealing algorithm. Larger values will make the algorithm more precise but slower.</p> <code>1</code> Source code in <code>src/DiscretePortfolioOptimization/metropolis.py</code> <pre><code>class PortfolioOptimizer:\n    \"\"\"\n    Class to optimize a portfolio using the Metropolis algorithm.\n\n    Args:\n        initial_portfolio: Portfolio, the initial portfolio to optimize\n        returns_df: pd.DataFrame, the returns of the assets in the portfolio\n        eta0: float, the smallest eta to use (larger eta -&gt; lower volatility)\n        eta1: float, the largest eta to use (larger eta -&gt; lower volatility)\n        n_etas: int, the number of etas to use, so the number of final optimized portfolios\n        gamma: float, the gamma parameter to use (larger gamma -&gt; more diversified portfolio)\n        delta: float, the delta parameter to use (larger delta -&gt; less cash in the portfolio)\n        n_therm_steps: int, the number of thermalization steps to use before starting the optimization\n        theta0: float, the initial theta for the Simulated Annealing algorithm. It should be so that\n            `theta0 * score_diff &lt;&lt; 1` where `score_diff` is the difference between the scores of two\n            portfolios separated by a random move.\n        theta1: float, the final theta for the Simulated Annealing algorithm. It should be so that\n            `theta1 * score_diff &gt;&gt; 1` where `score_diff` is the difference between the scores of two\n            portfolios separated by a random move.\n        n_thetas: int, the number of thetas to use in the Simulated Annealing algorithm. Larger values\n            will make the algorithm more precise but slower.\n        n_steps_per_theta: int, the number of steps per theta to use in the Simulated Annealing algorithm.\n            Larger values will make the algorithm more precise but slower.\n    \"\"\"\n\n    def __init__(\n        self,\n        initial_portfolio: Portfolio,\n        returns_df: pd.DataFrame,\n        eta0: float = 1e1,\n        eta1: float = 1e3,\n        n_etas: int = 10,\n        gamma: float = 0.0,\n        delta: float = 0.0,\n        n_therm_steps: int = 1_000,\n        theta0: float = 1,\n        theta1: float = 1e3,\n        n_thetas: int = 5_000,\n        n_steps_per_theta: int = 1,\n    ):\n        \"\"\"\n        Initialize the PortfolioOptimizer.\n\n        Args:\n            initial_portfolio: Portfolio, the initial portfolio to optimize\n            returns_df: pd.DataFrame, the returns of the assets in the portfolio\n            eta0: float, the smallest eta to use (larger eta -&gt; lower volatility)\n            eta1: float, the largest eta to use (larger eta -&gt; lower volatility)\n            n_etas: int, the number of etas to use, so the number of final optimized portfolios\n            gamma: float, the gamma parameter to use (larger gamma -&gt; more diversified portfolio)\n            delta: float, the delta parameter to use (larger delta -&gt; less cash in the portfolio)\n            n_therm_steps: int, the number of thermalization steps to use before starting the optimization\n            theta0: float, the initial theta for the Simulated Annealing algorithm. It should be so that\n                `theta0 * score_diff &lt;&lt; 1` where `score_diff` is the difference between the scores of two\n                portfolios separated by a random move.\n            theta1: float, the final theta for the Simulated Annealing algorithm. It should be so that\n                `theta1 * score_diff &gt;&gt; 1` where `score_diff` is the difference between the scores of two\n                portfolios separated by a random move.\n            n_thetas: int, the number of thetas to use in the Simulated Annealing algorithm. Larger values\n                will make the algorithm more precise but slower.\n            n_steps_per_theta: int, the number of steps per theta to use in the Simulated Annealing algorithm.\n                Larger values will make the algorithm more precise but slower.\n        \"\"\"\n        self.initial_portfolio = initial_portfolio.copy()\n        self.rng = initial_portfolio.rng  # share seed with portfolio if was provided\n        self.best_portfolios: List[Portfolio] = []\n        self._current_portfolio: Portfolio\n        self._current_score: float\n        self.gamma = gamma\n        self.delta = delta\n        # check that returns df is in *daily percentage* format\n        if not np.all(returns_df.mean() &gt;= -1):\n            warn(\n                \"Large negative returns detected,\"\n                \" remember that returns should be in *daily percentage* format.\"\n            )\n        if not np.all(returns_df.mean() &lt;= 1):\n            warn(\n                \"Large positive returns detected,\"\n                \" remember that returns should be in *daily percentage* format.\"\n            )\n        if not np.max(np.abs(returns_df.mean()) &gt;= 0.01):\n            warn(\n                \"Largest return is very small,\"\n                \" remember that returns should be in *daily percentage* format.\"\n            )\n        self.returns_df = returns_df\n        self.eta_schedule = np.geomspace(eta0, eta1, n_etas)\n        self.theta_schedule = self._prepare_exp_theta_schedule(\n            theta0, theta1, n_therm_steps, n_thetas, n_steps_per_theta\n        )\n\n    @staticmethod\n    def _portfolio_minus_energy(\n        eta: float,\n        gamma: float,\n        delta: float,\n        portfolio: Portfolio,\n        returns_df: pd.DataFrame,\n    ) -&gt; float:\n        \"\"\"\n        Compute the score of a portfolio.\n        The score is defined as:\n\n        `Return - eta * Volatility - gamma * sum(weights**2) - delta * cash_value / tot_value`\n\n        Args:\n            eta: float, the eta parameter to use (larger eta -&gt; lower volatility)\n            gamma: float, the gamma parameter to use (larger gamma -&gt; more diversified portfolio)\n            delta: float, the delta parameter to use (larger delta -&gt; less cash in the portfolio)\n            portfolio: Portfolio, the portfolio to evaluate\n            returns_df: pd.DataFrame, the returns of the assets in the portfolio\n\n        Returns:\n            float, the score of the portfolio\n        \"\"\"\n        portfolio_metrics = portfolio.portfolio_metrics(returns_df)\n        if gamma != 0:\n            # large gamma -&gt; diversified portfolio\n            gamma_term = gamma * float(np.sum(portfolio.weights**2))\n        else:\n            gamma_term = 0\n        if delta != 0:\n            # large delta -&gt; low cash\n            delta_term = delta * portfolio.cash_value / portfolio.tot_value\n        else:\n            delta_term = 0\n        return (\n            portfolio_metrics[\"Return\"]\n            - eta * portfolio_metrics[\"Volatility\"]  # large eta -&gt; low volatility\n            - gamma_term\n            - delta_term\n        )\n\n    @staticmethod\n    def _prepare_exp_theta_schedule(\n        theta0: float,\n        theta1: float,\n        n_therm_steps: int,\n        n_thetas: int,\n        n_step_per_theta: int,\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Prepare the theta schedule for the Metropolis algorithm.\n\n        Args:\n            theta0: float, the initial theta for the Simulated Annealing algorithm. It should be so that\n                `theta0 * score_diff &lt;&lt; 1` where `score_diff` is the difference between the scores of two\n                portfolios separated by a random move.\n            theta1: float, the final theta for the Simulated Annealing algorithm. It should be so that\n                `theta1 * score_diff &gt;&gt; 1` where `score_diff` is the difference between the scores of two\n                portfolios separated by a random move.\n            n_therm_steps: int, the number of thermalization steps to use before starting the optimization\n            n_thetas: int, the number of thetas to use in the Simulated Annealing algorithm. Larger values\n                will make the algorithm more precise but slower.\n            n_steps_per_theta: int, the number of steps per theta to use in the Simulated Annealing algorithm.\n                Larger values will make the algorithm more precise but slower.\n\n        Returns:\n            np.ndarray, the theta schedule to use in the Metropolis algorithm\n        \"\"\"\n        schedule1 = np.full(n_therm_steps, theta0)\n        schedule2 = np.linspace(np.log(theta0), np.log(theta1), n_thetas)\n        schedule2 = np.repeat(schedule2, n_step_per_theta)\n        schedule2 = np.exp(schedule2)\n        return np.concatenate([schedule1, schedule2])\n\n    def _step(self, eta: float, theta: float) -&gt; None:\n        \"\"\"\n        Perform a step of the Metropolis algorithm.\n        It results in potentially updating the `self._current_portfolio`\n        and `self._current_score` attributes.\n\n        Args:\n            eta: float, the eta parameter to use (larger eta -&gt; lower volatility)\n            theta: float, the theta parameter to use in the Metropolis algorithm\n\n        \"\"\"\n        new_portfolio = self._current_portfolio.copy()\n        new_portfolio.random_move()\n        new_score = self._portfolio_minus_energy(\n            eta, self.gamma, self.delta, new_portfolio, self.returns_df\n        )\n        if new_score &gt; self._current_score:\n            self._current_portfolio = new_portfolio\n            self._current_score = new_score\n        elif self.rng.random() &lt; np.exp(theta * (new_score - self._current_score)):\n            self._current_portfolio = new_portfolio\n            self._current_score = new_score\n        return\n\n    def run_fixed_eta(self, eta: float) -&gt; None:\n        \"\"\"\n        Run the optimization process for a fixed eta.\n        It will store the best portfolio found in `self.best_portfolios`.\n\n        Args:\n            eta: float, the eta parameter to use (larger eta -&gt; lower volatility)\n        \"\"\"\n        self._current_portfolio = self.initial_portfolio\n        self._current_score = self._portfolio_minus_energy(\n            eta, self.gamma, self.delta, self.initial_portfolio, self.returns_df\n        )\n        best_portfolio = self._current_portfolio\n        best_score = self._current_score\n\n        # progress bar\n        # Use Any type for theta_schedule_iter to accommodate both tqdm and marimo progress bar\n        theta_schedule_iter: Any\n        if mo.running_in_notebook():\n            theta_schedule_iter = mo.status.progress_bar(\n                self.theta_schedule,\n                title=\"Optimizing portfolio\",\n                subtitle=f\"with eta = {eta:.2e}\",\n                remove_on_exit=True,\n            )\n        else:\n            theta_schedule_iter = tqdm(\n                self.theta_schedule,\n                desc=f\"Optimizing portfolio with eta = {eta:.2e}\",\n                leave=False,\n            )\n\n        for theta in theta_schedule_iter:\n            self._step(eta, theta)\n            if self._current_score &gt; best_score:\n                best_portfolio = self._current_portfolio\n                best_score = self._current_score\n        best_portfolio.eta = eta\n        self.best_portfolios.append(best_portfolio)\n        return\n\n    def full_run(\n        self, callback: Optional[Callable[[\"PortfolioOptimizer\"], Any]] = None\n    ) -&gt; Any:\n        \"\"\"\n        Run the full optimization process.\n\n        Args:\n            callback: Optional function to call after each eta optimization\n\n        Returns:\n            The result of the callback if provided, otherwise None\n        \"\"\"\n        # progress bar\n        # Use Any type for eta_schedule_iter to accommodate both tqdm and marimo progress bar\n        eta_schedule_iter: Any\n        if mo.running_in_notebook():\n            eta_schedule_iter = mo.status.progress_bar(\n                self.eta_schedule, title=\"Collecting optimal portfolios\"\n            )\n        else:\n            eta_schedule_iter = tqdm(\n                self.eta_schedule, desc=\"Collecting optimal portfolios\"\n            )\n\n        callback_res: Any = None\n        for eta in eta_schedule_iter:\n            self.run_fixed_eta(eta)\n            if callback is not None:\n                callback_res = callback(self)\n\n        return callback_res\n</code></pre>"},{"location":"metropolis/#DiscretePortfolioOptimization.metropolis.PortfolioOptimizer.__init__","title":"<code>__init__(initial_portfolio, returns_df, eta0=10.0, eta1=1000.0, n_etas=10, gamma=0.0, delta=0.0, n_therm_steps=1000, theta0=1, theta1=1000.0, n_thetas=5000, n_steps_per_theta=1)</code>","text":"<p>Initialize the PortfolioOptimizer.</p> <p>Parameters:</p> Name Type Description Default <code>initial_portfolio</code> <code>Portfolio</code> <p>Portfolio, the initial portfolio to optimize</p> required <code>returns_df</code> <code>DataFrame</code> <p>pd.DataFrame, the returns of the assets in the portfolio</p> required <code>eta0</code> <code>float</code> <p>float, the smallest eta to use (larger eta -&gt; lower volatility)</p> <code>10.0</code> <code>eta1</code> <code>float</code> <p>float, the largest eta to use (larger eta -&gt; lower volatility)</p> <code>1000.0</code> <code>n_etas</code> <code>int</code> <p>int, the number of etas to use, so the number of final optimized portfolios</p> <code>10</code> <code>gamma</code> <code>float</code> <p>float, the gamma parameter to use (larger gamma -&gt; more diversified portfolio)</p> <code>0.0</code> <code>delta</code> <code>float</code> <p>float, the delta parameter to use (larger delta -&gt; less cash in the portfolio)</p> <code>0.0</code> <code>n_therm_steps</code> <code>int</code> <p>int, the number of thermalization steps to use before starting the optimization</p> <code>1000</code> <code>theta0</code> <code>float</code> <p>float, the initial theta for the Simulated Annealing algorithm. It should be so that <code>theta0 * score_diff &lt;&lt; 1</code> where <code>score_diff</code> is the difference between the scores of two portfolios separated by a random move.</p> <code>1</code> <code>theta1</code> <code>float</code> <p>float, the final theta for the Simulated Annealing algorithm. It should be so that <code>theta1 * score_diff &gt;&gt; 1</code> where <code>score_diff</code> is the difference between the scores of two portfolios separated by a random move.</p> <code>1000.0</code> <code>n_thetas</code> <code>int</code> <p>int, the number of thetas to use in the Simulated Annealing algorithm. Larger values will make the algorithm more precise but slower.</p> <code>5000</code> <code>n_steps_per_theta</code> <code>int</code> <p>int, the number of steps per theta to use in the Simulated Annealing algorithm. Larger values will make the algorithm more precise but slower.</p> <code>1</code> Source code in <code>src/DiscretePortfolioOptimization/metropolis.py</code> <pre><code>def __init__(\n    self,\n    initial_portfolio: Portfolio,\n    returns_df: pd.DataFrame,\n    eta0: float = 1e1,\n    eta1: float = 1e3,\n    n_etas: int = 10,\n    gamma: float = 0.0,\n    delta: float = 0.0,\n    n_therm_steps: int = 1_000,\n    theta0: float = 1,\n    theta1: float = 1e3,\n    n_thetas: int = 5_000,\n    n_steps_per_theta: int = 1,\n):\n    \"\"\"\n    Initialize the PortfolioOptimizer.\n\n    Args:\n        initial_portfolio: Portfolio, the initial portfolio to optimize\n        returns_df: pd.DataFrame, the returns of the assets in the portfolio\n        eta0: float, the smallest eta to use (larger eta -&gt; lower volatility)\n        eta1: float, the largest eta to use (larger eta -&gt; lower volatility)\n        n_etas: int, the number of etas to use, so the number of final optimized portfolios\n        gamma: float, the gamma parameter to use (larger gamma -&gt; more diversified portfolio)\n        delta: float, the delta parameter to use (larger delta -&gt; less cash in the portfolio)\n        n_therm_steps: int, the number of thermalization steps to use before starting the optimization\n        theta0: float, the initial theta for the Simulated Annealing algorithm. It should be so that\n            `theta0 * score_diff &lt;&lt; 1` where `score_diff` is the difference between the scores of two\n            portfolios separated by a random move.\n        theta1: float, the final theta for the Simulated Annealing algorithm. It should be so that\n            `theta1 * score_diff &gt;&gt; 1` where `score_diff` is the difference between the scores of two\n            portfolios separated by a random move.\n        n_thetas: int, the number of thetas to use in the Simulated Annealing algorithm. Larger values\n            will make the algorithm more precise but slower.\n        n_steps_per_theta: int, the number of steps per theta to use in the Simulated Annealing algorithm.\n            Larger values will make the algorithm more precise but slower.\n    \"\"\"\n    self.initial_portfolio = initial_portfolio.copy()\n    self.rng = initial_portfolio.rng  # share seed with portfolio if was provided\n    self.best_portfolios: List[Portfolio] = []\n    self._current_portfolio: Portfolio\n    self._current_score: float\n    self.gamma = gamma\n    self.delta = delta\n    # check that returns df is in *daily percentage* format\n    if not np.all(returns_df.mean() &gt;= -1):\n        warn(\n            \"Large negative returns detected,\"\n            \" remember that returns should be in *daily percentage* format.\"\n        )\n    if not np.all(returns_df.mean() &lt;= 1):\n        warn(\n            \"Large positive returns detected,\"\n            \" remember that returns should be in *daily percentage* format.\"\n        )\n    if not np.max(np.abs(returns_df.mean()) &gt;= 0.01):\n        warn(\n            \"Largest return is very small,\"\n            \" remember that returns should be in *daily percentage* format.\"\n        )\n    self.returns_df = returns_df\n    self.eta_schedule = np.geomspace(eta0, eta1, n_etas)\n    self.theta_schedule = self._prepare_exp_theta_schedule(\n        theta0, theta1, n_therm_steps, n_thetas, n_steps_per_theta\n    )\n</code></pre>"},{"location":"metropolis/#DiscretePortfolioOptimization.metropolis.PortfolioOptimizer.full_run","title":"<code>full_run(callback=None)</code>","text":"<p>Run the full optimization process.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Optional[Callable[[PortfolioOptimizer], Any]]</code> <p>Optional function to call after each eta optimization</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the callback if provided, otherwise None</p> Source code in <code>src/DiscretePortfolioOptimization/metropolis.py</code> <pre><code>def full_run(\n    self, callback: Optional[Callable[[\"PortfolioOptimizer\"], Any]] = None\n) -&gt; Any:\n    \"\"\"\n    Run the full optimization process.\n\n    Args:\n        callback: Optional function to call after each eta optimization\n\n    Returns:\n        The result of the callback if provided, otherwise None\n    \"\"\"\n    # progress bar\n    # Use Any type for eta_schedule_iter to accommodate both tqdm and marimo progress bar\n    eta_schedule_iter: Any\n    if mo.running_in_notebook():\n        eta_schedule_iter = mo.status.progress_bar(\n            self.eta_schedule, title=\"Collecting optimal portfolios\"\n        )\n    else:\n        eta_schedule_iter = tqdm(\n            self.eta_schedule, desc=\"Collecting optimal portfolios\"\n        )\n\n    callback_res: Any = None\n    for eta in eta_schedule_iter:\n        self.run_fixed_eta(eta)\n        if callback is not None:\n            callback_res = callback(self)\n\n    return callback_res\n</code></pre>"},{"location":"metropolis/#DiscretePortfolioOptimization.metropolis.PortfolioOptimizer.run_fixed_eta","title":"<code>run_fixed_eta(eta)</code>","text":"<p>Run the optimization process for a fixed eta. It will store the best portfolio found in <code>self.best_portfolios</code>.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>float</code> <p>float, the eta parameter to use (larger eta -&gt; lower volatility)</p> required Source code in <code>src/DiscretePortfolioOptimization/metropolis.py</code> <pre><code>def run_fixed_eta(self, eta: float) -&gt; None:\n    \"\"\"\n    Run the optimization process for a fixed eta.\n    It will store the best portfolio found in `self.best_portfolios`.\n\n    Args:\n        eta: float, the eta parameter to use (larger eta -&gt; lower volatility)\n    \"\"\"\n    self._current_portfolio = self.initial_portfolio\n    self._current_score = self._portfolio_minus_energy(\n        eta, self.gamma, self.delta, self.initial_portfolio, self.returns_df\n    )\n    best_portfolio = self._current_portfolio\n    best_score = self._current_score\n\n    # progress bar\n    # Use Any type for theta_schedule_iter to accommodate both tqdm and marimo progress bar\n    theta_schedule_iter: Any\n    if mo.running_in_notebook():\n        theta_schedule_iter = mo.status.progress_bar(\n            self.theta_schedule,\n            title=\"Optimizing portfolio\",\n            subtitle=f\"with eta = {eta:.2e}\",\n            remove_on_exit=True,\n        )\n    else:\n        theta_schedule_iter = tqdm(\n            self.theta_schedule,\n            desc=f\"Optimizing portfolio with eta = {eta:.2e}\",\n            leave=False,\n        )\n\n    for theta in theta_schedule_iter:\n        self._step(eta, theta)\n        if self._current_score &gt; best_score:\n            best_portfolio = self._current_portfolio\n            best_score = self._current_score\n    best_portfolio.eta = eta\n    self.best_portfolios.append(best_portfolio)\n    return\n</code></pre>"},{"location":"portfolio/","title":"Portfolio","text":""},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio","title":"<code>DiscretePortfolioOptimization.portfolio</code>","text":""},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio.Portfolio","title":"<code>Portfolio</code>","text":"<p>Class to represent a portfolio of assets.</p> <p>Attributes:</p> Name Type Description <code>current_prices</code> <code>NDArray[floating]</code> <p>list[float], the current prices of the assets</p> <code>tot_value</code> <code>float</code> <p>float, the total value of the portfolio</p> <code>allocations</code> <code>NDArray[floating]</code> <p>list[float], the number of shares of each asset</p> <code>cash_value</code> <code>float</code> <p>float, the cash value of the portfolio</p> <code>seed</code> <code>float</code> <p>int, the seed for the random number generator</p> Source code in <code>src/DiscretePortfolioOptimization/portfolio.py</code> <pre><code>class Portfolio:\n    \"\"\"\n    Class to represent a portfolio of assets.\n\n    Attributes:\n        current_prices: list[float], the current prices of the assets\n        tot_value: float, the total value of the portfolio\n        allocations: list[float], the number of shares of each asset\n        cash_value: float, the cash value of the portfolio\n        seed: int, the seed for the random number generator\n    \"\"\"\n\n    current_prices: NDArray[np.floating]\n    allocations: NDArray[np.floating]\n    weights: NDArray[np.floating]\n\n    def __init__(\n        self,\n        current_prices: Union[List[float], NDArray[np.floating]],\n        tot_value: Optional[float] = None,\n        allocations: Optional[Union[List[float], NDArray[np.floating]]] = None,\n        cash_value: float = 0,\n        seed: Optional[int] = None,\n    ):\n        \"\"\"\n        Initialize the Portfolio object using either the total value of the portfolio\n        (and random allocations) or each allocation (the total value will be computed).\n\n        Args:\n            current_prices: list[float], the current prices of the assets\n            tot_value: float, the total value of the portfolio\n            allocations: list[float], the number of shares of each asset\n            cash_value: float, the cash value of the portfolio\n            seed: int, the seed for the random number generator\n        \"\"\"\n        self.current_prices = np.array(current_prices, dtype=float)\n        self.num_assets = len(current_prices)\n        self.eta: Optional[float] = (\n            None  # eta is not used in this class, but it is used in the optimization class\n        )\n        self.asset_value: float\n        self.tot_value: float\n        self.cash_value: float\n\n        if seed is not None:\n            self.rng = np.random.default_rng(seed)\n        else:\n            self.rng = np.random.default_rng()\n\n        if (allocations is not None) and (tot_value is not None):\n            raise RuntimeError(\n                \"Refusing to create a portfolio with both allocations and total value.\"\n                \"Provide allocations only and the total value will be computed.\"\n            )\n        if (allocations is None) and (tot_value is None):\n            raise RuntimeError(\n                \"Cannot create a portfolio without `allocations` or (`tot_value`).\"\n            )\n        elif allocations is None and tot_value is not None:\n            self.tot_value = tot_value\n            self.allocations = self._random_allocations()\n        elif tot_value is None and allocations is not None:\n            self.allocations = np.array(allocations, dtype=float)\n            self.tot_value = float(self.current_prices @ self.allocations + cash_value)\n\n        self._sync_values()  # self.asset_value, self.cash_value\n        self._sync_weights()  # self.weights\n\n    def _sync_values(self) -&gt; None:\n        \"\"\"\n        Synchronize the asset and cash values with the current prices and allocations.\n        \"\"\"\n        self.asset_value = float(self.current_prices @ self.allocations)\n        self.cash_value = self.tot_value - self.asset_value\n\n    def _sync_weights(self) -&gt; None:\n        \"\"\"\n        Synchronize the weights with the current prices and allocations.\n        \"\"\"\n        self.weights = np.array(\n            [\n                self.current_prices[i] * self.allocations[i] / self.asset_value\n                for i in range(self.num_assets)\n            ]\n        )\n\n    def _random_allocations(self) -&gt; NDArray[np.floating]:\n        \"\"\"\n        Generate random allocations for the assets.\n        \"\"\"\n        curr_value = 0\n        allocations = [0 for _ in range(self.num_assets)]\n        available_poss = np.arange(self.num_assets)\n        while len(available_poss) != 0:\n            t_pos = self.rng.choice(available_poss)\n            t_value = self.current_prices[t_pos]\n            if curr_value + t_value &lt;= self.tot_value:\n                curr_value = curr_value + t_value\n                allocations[t_pos] += 1\n            else:\n                available_poss = available_poss[available_poss != t_pos]\n        return np.array(allocations, dtype=float)\n\n    def random_move(self) -&gt; None:\n        \"\"\"\n        Perform a random move in the portfolio changing the allocations of two assets.\n        The two assets are chosen randomly and the move is the smallest possible in terms of value.\n        \"\"\"\n        # determine two random assets\n        available_poss = np.arange(self.num_assets)\n        pos1 = self.rng.choice(available_poss)\n        price1 = self.current_prices[pos1]\n        available_poss = available_poss[available_poss != pos1]\n        pos2 = self.rng.choice(available_poss)\n        price2 = self.current_prices[pos2]\n\n        # find smallest (in term of size) move\n        largest_value = np.argmax([price1, price2])\n        if largest_value == 0:\n            num1 = 1\n            num2 = np.round(price1 / price2)\n        else:\n            num1 = np.round(price2 / price1)\n            num2 = 1\n\n        # determine the direction of the move\n        first_2_second = self.rng.choice([True, False])\n        move_done = False\n        if first_2_second:\n            if ((num2 * price2 - num1 * price1) &lt;= self.cash_value) and (\n                self.allocations[pos1] - num1 &gt;= 0\n            ):\n                self.allocations[pos1] -= num1\n                self.allocations[pos2] += num2\n                move_done = True\n        else:\n            if ((num1 * price1 - num2 * price2) &lt;= self.cash_value) and (\n                self.allocations[pos2] - num2 &gt;= 0\n            ):\n                self.allocations[pos1] += num1\n                self.allocations[pos2] -= num2\n                move_done = True\n        if not move_done:\n            if not first_2_second:\n                if ((num2 * price2 - num1 * price1) &lt;= self.cash_value) and (\n                    self.allocations[pos1] - num1 &gt;= 0\n                ):\n                    self.allocations[pos1] -= num1\n                    self.allocations[pos2] += num2\n            else:\n                if ((num1 * price1 - num2 * price2) &lt;= self.cash_value) and (\n                    self.allocations[pos2] - num2 &gt;= 0\n                ):\n                    self.allocations[pos1] += num1\n                    self.allocations[pos2] -= num2\n        self._sync_values()\n        self._sync_weights()\n        return\n\n    def get_day_return(\n        self, returns_df: pd.DataFrame, account_for_cash: bool = True\n    ) -&gt; float:\n        \"\"\"\n        Compute the return of the portfolio for a day.\n        If `account_for_cash` is True, the return is multiplied by the fraction of the total value\n        that is allocated to assets.\n\n        Args:\n            returns_df: pd.DataFrame, the returns of the assets\n            account_for_cash: bool, whether to account for the cash in the portfolio\n\n        Returns:\n            float, the return of the portfolio\n\n        \"\"\"\n        if account_for_cash:\n            # cash has no return\n            allocated_frac = (self.tot_value - self.cash_value) / self.tot_value\n            return np.sum(returns_df.mean() * self.weights) * allocated_frac\n        else:\n            return np.sum(returns_df.mean() * self.weights)\n\n    def get_day_volatility(\n        self, returns_df: pd.DataFrame, account_for_cash: bool = True\n    ) -&gt; float:\n        \"\"\"\n        Compute the volatility of the portfolio for a day.\n        The volatility is calculated as the square root of the portfolio variance (w' * Sigma * w),\n        where w is the vector of asset weights and Sigma is the covariance matrix of returns.\n        If `account_for_cash` is True, the volatility is multiplied by the fraction of the total value\n        that is allocated to assets.\n\n        Args:\n            returns_df: pd.DataFrame, the returns of the assets\n            account_for_cash: bool, whether to account for the cash in the portfolio\n\n        Returns:\n            float, the volatility of the portfolio\n        \"\"\"\n        cov_matrix = returns_df.cov()\n        if account_for_cash:\n            # cash has no volatility\n            allocated_frac = (self.tot_value - self.cash_value) / self.tot_value\n            return float(\n                np.sqrt(self.weights.T @ (cov_matrix) @ self.weights) * allocated_frac\n            )\n        else:\n            return float(np.sqrt(self.weights.T @ (cov_matrix) @ self.weights))\n\n    def get_sharpe(\n        self, returns_df: pd.DataFrame, account_for_cash: bool = True\n    ) -&gt; float:\n        \"\"\"\n        Compute the Sharpe ratio of the portfolio.\n        If `account_for_cash` is True, the Sharpe ratio is computed using the fraction of the total value\n        that is allocated to assets.\n\n        Args:\n            returns_df: pd.DataFrame, the returns of the assets\n            account_for_cash: bool, whether to account for the cash in the portfolio\n\n        Returns:\n            float, the Sharpe ratio of the portfolio\n        \"\"\"\n        yret = self.get_day_return(returns_df, account_for_cash)\n        ycov = self.get_day_volatility(returns_df, account_for_cash)\n        return yret / ycov\n\n    def portfolio_metrics(\n        self, returns_df: pd.DataFrame, account_for_cash: bool = True\n    ) -&gt; Dict[str, float]:\n        \"\"\"\n        Compute the return, volatility, and Sharpe ratio of the portfolio.\n        If `account_for_cash` is True, the metrics are computed using the fraction of the total value\n        that is allocated to assets.\n\n        Args:\n            returns_df: pd.DataFrame, the returns of the assets\n            account_for_cash: bool, whether to account for the cash in the portfolio\n\n        Returns:\n            dict, a dictionary with the return, volatility, and Sharpe ratio of the portfolio\n        \"\"\"\n        ret = self.get_day_return(returns_df, account_for_cash)\n        vol = self.get_day_volatility(returns_df, account_for_cash)\n        return {\n            \"Return\": ret,\n            \"Volatility\": vol,\n            \"Sharpe Ratio\": ret / vol,\n        }\n\n    def copy(self) -&gt; \"Portfolio\":\n        \"\"\"\n        Return a copy of the Portfolio object.\n        \"\"\"\n        # Convert numpy arrays to lists and explicitly cast them for type safety\n        # current_prices_list: List[float] = [float(x) for x in self.current_prices]\n        # allocations_list: List[float] = [float(x) for x in self.allocations]\n\n        return Portfolio(\n            self.current_prices,\n            None,\n            self.allocations,\n            self.cash_value,\n        )\n\n    def __str__(self) -&gt; str:\n        return (\n            f\"Portfolio with total value of {round(float(self.tot_value), ndigits=1)}\"\n            f\" (of which {round(self.asset_value, ndigits=1)} in assets and {round(self.cash_value, ndigits=1)} cash)\"\n            f\" and allocations {self.allocations}.\"\n        )\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n</code></pre>"},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio.Portfolio.__init__","title":"<code>__init__(current_prices, tot_value=None, allocations=None, cash_value=0, seed=None)</code>","text":"<p>Initialize the Portfolio object using either the total value of the portfolio (and random allocations) or each allocation (the total value will be computed).</p> <p>Parameters:</p> Name Type Description Default <code>current_prices</code> <code>Union[List[float], NDArray[floating]]</code> <p>list[float], the current prices of the assets</p> required <code>tot_value</code> <code>Optional[float]</code> <p>float, the total value of the portfolio</p> <code>None</code> <code>allocations</code> <code>Optional[Union[List[float], NDArray[floating]]]</code> <p>list[float], the number of shares of each asset</p> <code>None</code> <code>cash_value</code> <code>float</code> <p>float, the cash value of the portfolio</p> <code>0</code> <code>seed</code> <code>Optional[int]</code> <p>int, the seed for the random number generator</p> <code>None</code> Source code in <code>src/DiscretePortfolioOptimization/portfolio.py</code> <pre><code>def __init__(\n    self,\n    current_prices: Union[List[float], NDArray[np.floating]],\n    tot_value: Optional[float] = None,\n    allocations: Optional[Union[List[float], NDArray[np.floating]]] = None,\n    cash_value: float = 0,\n    seed: Optional[int] = None,\n):\n    \"\"\"\n    Initialize the Portfolio object using either the total value of the portfolio\n    (and random allocations) or each allocation (the total value will be computed).\n\n    Args:\n        current_prices: list[float], the current prices of the assets\n        tot_value: float, the total value of the portfolio\n        allocations: list[float], the number of shares of each asset\n        cash_value: float, the cash value of the portfolio\n        seed: int, the seed for the random number generator\n    \"\"\"\n    self.current_prices = np.array(current_prices, dtype=float)\n    self.num_assets = len(current_prices)\n    self.eta: Optional[float] = (\n        None  # eta is not used in this class, but it is used in the optimization class\n    )\n    self.asset_value: float\n    self.tot_value: float\n    self.cash_value: float\n\n    if seed is not None:\n        self.rng = np.random.default_rng(seed)\n    else:\n        self.rng = np.random.default_rng()\n\n    if (allocations is not None) and (tot_value is not None):\n        raise RuntimeError(\n            \"Refusing to create a portfolio with both allocations and total value.\"\n            \"Provide allocations only and the total value will be computed.\"\n        )\n    if (allocations is None) and (tot_value is None):\n        raise RuntimeError(\n            \"Cannot create a portfolio without `allocations` or (`tot_value`).\"\n        )\n    elif allocations is None and tot_value is not None:\n        self.tot_value = tot_value\n        self.allocations = self._random_allocations()\n    elif tot_value is None and allocations is not None:\n        self.allocations = np.array(allocations, dtype=float)\n        self.tot_value = float(self.current_prices @ self.allocations + cash_value)\n\n    self._sync_values()  # self.asset_value, self.cash_value\n    self._sync_weights()  # self.weights\n</code></pre>"},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio.Portfolio.copy","title":"<code>copy()</code>","text":"<p>Return a copy of the Portfolio object.</p> Source code in <code>src/DiscretePortfolioOptimization/portfolio.py</code> <pre><code>def copy(self) -&gt; \"Portfolio\":\n    \"\"\"\n    Return a copy of the Portfolio object.\n    \"\"\"\n    # Convert numpy arrays to lists and explicitly cast them for type safety\n    # current_prices_list: List[float] = [float(x) for x in self.current_prices]\n    # allocations_list: List[float] = [float(x) for x in self.allocations]\n\n    return Portfolio(\n        self.current_prices,\n        None,\n        self.allocations,\n        self.cash_value,\n    )\n</code></pre>"},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio.Portfolio.get_day_return","title":"<code>get_day_return(returns_df, account_for_cash=True)</code>","text":"<p>Compute the return of the portfolio for a day. If <code>account_for_cash</code> is True, the return is multiplied by the fraction of the total value that is allocated to assets.</p> <p>Parameters:</p> Name Type Description Default <code>returns_df</code> <code>DataFrame</code> <p>pd.DataFrame, the returns of the assets</p> required <code>account_for_cash</code> <code>bool</code> <p>bool, whether to account for the cash in the portfolio</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>float, the return of the portfolio</p> Source code in <code>src/DiscretePortfolioOptimization/portfolio.py</code> <pre><code>def get_day_return(\n    self, returns_df: pd.DataFrame, account_for_cash: bool = True\n) -&gt; float:\n    \"\"\"\n    Compute the return of the portfolio for a day.\n    If `account_for_cash` is True, the return is multiplied by the fraction of the total value\n    that is allocated to assets.\n\n    Args:\n        returns_df: pd.DataFrame, the returns of the assets\n        account_for_cash: bool, whether to account for the cash in the portfolio\n\n    Returns:\n        float, the return of the portfolio\n\n    \"\"\"\n    if account_for_cash:\n        # cash has no return\n        allocated_frac = (self.tot_value - self.cash_value) / self.tot_value\n        return np.sum(returns_df.mean() * self.weights) * allocated_frac\n    else:\n        return np.sum(returns_df.mean() * self.weights)\n</code></pre>"},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio.Portfolio.get_day_volatility","title":"<code>get_day_volatility(returns_df, account_for_cash=True)</code>","text":"<p>Compute the volatility of the portfolio for a day. The volatility is calculated as the square root of the portfolio variance (w' * Sigma * w), where w is the vector of asset weights and Sigma is the covariance matrix of returns. If <code>account_for_cash</code> is True, the volatility is multiplied by the fraction of the total value that is allocated to assets.</p> <p>Parameters:</p> Name Type Description Default <code>returns_df</code> <code>DataFrame</code> <p>pd.DataFrame, the returns of the assets</p> required <code>account_for_cash</code> <code>bool</code> <p>bool, whether to account for the cash in the portfolio</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>float, the volatility of the portfolio</p> Source code in <code>src/DiscretePortfolioOptimization/portfolio.py</code> <pre><code>def get_day_volatility(\n    self, returns_df: pd.DataFrame, account_for_cash: bool = True\n) -&gt; float:\n    \"\"\"\n    Compute the volatility of the portfolio for a day.\n    The volatility is calculated as the square root of the portfolio variance (w' * Sigma * w),\n    where w is the vector of asset weights and Sigma is the covariance matrix of returns.\n    If `account_for_cash` is True, the volatility is multiplied by the fraction of the total value\n    that is allocated to assets.\n\n    Args:\n        returns_df: pd.DataFrame, the returns of the assets\n        account_for_cash: bool, whether to account for the cash in the portfolio\n\n    Returns:\n        float, the volatility of the portfolio\n    \"\"\"\n    cov_matrix = returns_df.cov()\n    if account_for_cash:\n        # cash has no volatility\n        allocated_frac = (self.tot_value - self.cash_value) / self.tot_value\n        return float(\n            np.sqrt(self.weights.T @ (cov_matrix) @ self.weights) * allocated_frac\n        )\n    else:\n        return float(np.sqrt(self.weights.T @ (cov_matrix) @ self.weights))\n</code></pre>"},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio.Portfolio.get_sharpe","title":"<code>get_sharpe(returns_df, account_for_cash=True)</code>","text":"<p>Compute the Sharpe ratio of the portfolio. If <code>account_for_cash</code> is True, the Sharpe ratio is computed using the fraction of the total value that is allocated to assets.</p> <p>Parameters:</p> Name Type Description Default <code>returns_df</code> <code>DataFrame</code> <p>pd.DataFrame, the returns of the assets</p> required <code>account_for_cash</code> <code>bool</code> <p>bool, whether to account for the cash in the portfolio</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>float, the Sharpe ratio of the portfolio</p> Source code in <code>src/DiscretePortfolioOptimization/portfolio.py</code> <pre><code>def get_sharpe(\n    self, returns_df: pd.DataFrame, account_for_cash: bool = True\n) -&gt; float:\n    \"\"\"\n    Compute the Sharpe ratio of the portfolio.\n    If `account_for_cash` is True, the Sharpe ratio is computed using the fraction of the total value\n    that is allocated to assets.\n\n    Args:\n        returns_df: pd.DataFrame, the returns of the assets\n        account_for_cash: bool, whether to account for the cash in the portfolio\n\n    Returns:\n        float, the Sharpe ratio of the portfolio\n    \"\"\"\n    yret = self.get_day_return(returns_df, account_for_cash)\n    ycov = self.get_day_volatility(returns_df, account_for_cash)\n    return yret / ycov\n</code></pre>"},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio.Portfolio.portfolio_metrics","title":"<code>portfolio_metrics(returns_df, account_for_cash=True)</code>","text":"<p>Compute the return, volatility, and Sharpe ratio of the portfolio. If <code>account_for_cash</code> is True, the metrics are computed using the fraction of the total value that is allocated to assets.</p> <p>Parameters:</p> Name Type Description Default <code>returns_df</code> <code>DataFrame</code> <p>pd.DataFrame, the returns of the assets</p> required <code>account_for_cash</code> <code>bool</code> <p>bool, whether to account for the cash in the portfolio</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>dict, a dictionary with the return, volatility, and Sharpe ratio of the portfolio</p> Source code in <code>src/DiscretePortfolioOptimization/portfolio.py</code> <pre><code>def portfolio_metrics(\n    self, returns_df: pd.DataFrame, account_for_cash: bool = True\n) -&gt; Dict[str, float]:\n    \"\"\"\n    Compute the return, volatility, and Sharpe ratio of the portfolio.\n    If `account_for_cash` is True, the metrics are computed using the fraction of the total value\n    that is allocated to assets.\n\n    Args:\n        returns_df: pd.DataFrame, the returns of the assets\n        account_for_cash: bool, whether to account for the cash in the portfolio\n\n    Returns:\n        dict, a dictionary with the return, volatility, and Sharpe ratio of the portfolio\n    \"\"\"\n    ret = self.get_day_return(returns_df, account_for_cash)\n    vol = self.get_day_volatility(returns_df, account_for_cash)\n    return {\n        \"Return\": ret,\n        \"Volatility\": vol,\n        \"Sharpe Ratio\": ret / vol,\n    }\n</code></pre>"},{"location":"portfolio/#DiscretePortfolioOptimization.portfolio.Portfolio.random_move","title":"<code>random_move()</code>","text":"<p>Perform a random move in the portfolio changing the allocations of two assets. The two assets are chosen randomly and the move is the smallest possible in terms of value.</p> Source code in <code>src/DiscretePortfolioOptimization/portfolio.py</code> <pre><code>def random_move(self) -&gt; None:\n    \"\"\"\n    Perform a random move in the portfolio changing the allocations of two assets.\n    The two assets are chosen randomly and the move is the smallest possible in terms of value.\n    \"\"\"\n    # determine two random assets\n    available_poss = np.arange(self.num_assets)\n    pos1 = self.rng.choice(available_poss)\n    price1 = self.current_prices[pos1]\n    available_poss = available_poss[available_poss != pos1]\n    pos2 = self.rng.choice(available_poss)\n    price2 = self.current_prices[pos2]\n\n    # find smallest (in term of size) move\n    largest_value = np.argmax([price1, price2])\n    if largest_value == 0:\n        num1 = 1\n        num2 = np.round(price1 / price2)\n    else:\n        num1 = np.round(price2 / price1)\n        num2 = 1\n\n    # determine the direction of the move\n    first_2_second = self.rng.choice([True, False])\n    move_done = False\n    if first_2_second:\n        if ((num2 * price2 - num1 * price1) &lt;= self.cash_value) and (\n            self.allocations[pos1] - num1 &gt;= 0\n        ):\n            self.allocations[pos1] -= num1\n            self.allocations[pos2] += num2\n            move_done = True\n    else:\n        if ((num1 * price1 - num2 * price2) &lt;= self.cash_value) and (\n            self.allocations[pos2] - num2 &gt;= 0\n        ):\n            self.allocations[pos1] += num1\n            self.allocations[pos2] -= num2\n            move_done = True\n    if not move_done:\n        if not first_2_second:\n            if ((num2 * price2 - num1 * price1) &lt;= self.cash_value) and (\n                self.allocations[pos1] - num1 &gt;= 0\n            ):\n                self.allocations[pos1] -= num1\n                self.allocations[pos2] += num2\n        else:\n            if ((num1 * price1 - num2 * price2) &lt;= self.cash_value) and (\n                self.allocations[pos2] - num2 &gt;= 0\n            ):\n                self.allocations[pos1] += num1\n                self.allocations[pos2] -= num2\n    self._sync_values()\n    self._sync_weights()\n    return\n</code></pre>"},{"location":"yfinance_download/","title":"YFinance Download","text":""},{"location":"yfinance_download/#DiscretePortfolioOptimization.yfinance_download","title":"<code>DiscretePortfolioOptimization.yfinance_download</code>","text":""},{"location":"yfinance_download/#DiscretePortfolioOptimization.yfinance_download.currency_conversion","title":"<code>currency_conversion(data, target_currency)</code>","text":"<p>Convert the currency of the stock prices in the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>pd.DataFrame, the stock prices</p> required <code>currency</code> <p>str, the currency to convert to (e.g., 'USD', 'EUR')</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame, the stock prices converted to the specified currency</p> Source code in <code>src/DiscretePortfolioOptimization/yfinance_download.py</code> <pre><code>def currency_conversion(data: pd.DataFrame, target_currency: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the currency of the stock prices in the DataFrame.\n\n    Args:\n        data: pd.DataFrame, the stock prices\n        currency: str, the currency to convert to (e.g., 'USD', 'EUR')\n\n    Returns:\n        pd.DataFrame, the stock prices converted to the specified currency\n    \"\"\"\n    tickers = data.columns.tolist()\n    currency_map = _get_ticker_currencies(tickers)\n\n    all_currency = list(set(currency_map.values()))\n    all_currency_not_target = [c for c in all_currency if c != target_currency]\n\n    currency_conversion = {}\n    forex_list = []\n    for cur in all_currency_not_target:\n        if target_currency == \"USD\":\n            fx_ticker = f\"{cur}=X\"\n        else:\n            fx_ticker = f\"{target_currency}{cur}=X\"\n        forex_list.append(fx_ticker)\n        currency_conversion[cur] = fx_ticker\n\n    if len(forex_list) == 0:\n        return data\n    else:\n        fx_history = yf.Tickers(forex_list).history(\n            period=\"max\", auto_adjust=True, progress=False\n        )\n        if (fx_history is None) or (fx_history.empty):\n            raise ValueError(\"No forex data found for currency conversion\")\n        fx_hist_close = fx_history[\"Close\"]\n\n        # Align prices and forex, using forward fill for missing values\n        data_al, fx_al = data.align(fx_hist_close, join=\"left\", axis=0)\n        fx_al = fx_al.ffill()\n\n        for col in data_al.columns:\n            reference_cur = currency_map[col]\n            if reference_cur != target_currency:\n                fx_col = currency_conversion[reference_cur]\n                data_al.loc[:, col] /= fx_al.loc[:, fx_col]\n\n        return data_al\n</code></pre>"},{"location":"yfinance_download/#DiscretePortfolioOptimization.yfinance_download.download_close_price","title":"<code>download_close_price(ticker)</code>","text":"<p>Download the close price of a stock from Yahoo Finance.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>str, the ticker (name) of the stock to download</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series, the close price of the stock</p> Source code in <code>src/DiscretePortfolioOptimization/yfinance_download.py</code> <pre><code>def download_close_price(ticker: str) -&gt; pd.Series:\n    \"\"\"\n    Download the close price of a stock from Yahoo Finance.\n\n    Args:\n        ticker: str, the ticker (name) of the stock to download\n\n    Returns:\n        pd.Series, the close price of the stock\n    \"\"\"\n    # cast ticker to upper case\n    ticker = ticker.upper()\n    data = yf.download(ticker, period=\"max\", progress=False, auto_adjust=True)\n    if (data is None) or (data.empty):\n        raise ValueError(f\"No data found for ticker {ticker}\")\n    else:\n        return data[\"Close\"][ticker]\n</code></pre>"},{"location":"yfinance_download/#DiscretePortfolioOptimization.yfinance_download.get_close_price_df","title":"<code>get_close_price_df(tickers, drop_missing_dates=True, target_currency='USD')</code>","text":"<p>Download the close price of a list of stocks from Yahoo Finance.</p> <p>Parameters:</p> Name Type Description Default <code>tickers</code> <code>str</code> <p>str, a string of tickers separated by a comma</p> required <code>drop_missing_dates</code> <code>bool</code> <p>bool, if True, drop dates for which at least one ticker is missing</p> <code>True</code> <code>target_currency</code> <code>str</code> <p>str, the currency to convert the stock prices to (default is 'USD')</p> <code>'USD'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame, the close price of the stocks</p> <code>List[str]</code> <p>list, the tickers that were successfully downloaded</p> <code>List[str]</code> <p>list, the tickers that were not found</p> Source code in <code>src/DiscretePortfolioOptimization/yfinance_download.py</code> <pre><code>def get_close_price_df(\n    tickers: str, drop_missing_dates: bool = True, target_currency: str = \"USD\"\n) -&gt; Tuple[pd.DataFrame, List[str], List[str]]:\n    \"\"\"\n    Download the close price of a list of stocks from Yahoo Finance.\n\n    Args:\n        tickers: str, a string of tickers separated by a comma\n        drop_missing_dates: bool, if True, drop dates for which at least one ticker is missing\n        target_currency: str, the currency to convert the stock prices to (default is 'USD')\n\n    Returns:\n        pd.DataFrame, the close price of the stocks\n        list, the tickers that were successfully downloaded\n        list, the tickers that were not found\n    \"\"\"\n    all_data = dict()\n    symbols = [x.strip() for x in tickers.split(\",\")]\n\n    # define progress bar\n    # Use Any for progress bar to accommodate both tqdm and marimo progress bar\n    symbols_iter: Any\n    if mo.running_in_notebook():\n        symbols_iter = mo.status.progress_bar(\n            symbols, title=\"Downloading Yahoo finance data\"\n        )\n    else:\n        symbols_iter = tqdm(symbols, desc=\"Downloading Yahoo finance data\")\n\n    ticker_hits: List[str] = []\n    ticker_misses: List[str] = []\n    for ticker in symbols_iter:\n        try:\n            t_data = download_close_price(ticker)\n        except Exception as e:\n            print(f\"Error downloading {ticker}: {e}\")\n            t_data = pd.Series()\n        if len(t_data) &gt; 0:\n            all_data[ticker] = t_data\n            ticker_hits.append(ticker)\n        else:\n            ticker_misses.append(ticker)\n            print(f\"Ticker {ticker} not found, skipping\")\n\n    if drop_missing_dates:\n        # drop missing dates\n        res_df = pd.DataFrame(all_data).dropna()\n        # convert data to target currency\n        res_df = currency_conversion(res_df, target_currency=target_currency).dropna()\n    else:\n        # fill missing dates with NaN\n        res_df = pd.DataFrame(all_data)\n        # convert data to target currency\n        res_df = currency_conversion(res_df, target_currency=target_currency)\n\n    return res_df, ticker_hits, ticker_misses\n</code></pre>"}]}